/*
 * Copyright(c) 2020 ADLINK Technology Limited and others
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0, or the Eclipse Distribution License
 * v. 1.0 which is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: EPL-2.0 OR BSD-3-Clause
 */

#include <assert.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>

#include "idl/version.h"
#include "idl/retcode.h"
#include "idl/processor.h"
#include "idl/string.h"

#include "idlpy/backendPyUtils.h"
#include "idlpy/backendPyType.h"

#ifdef _WIN32
#pragma warning(disable : 4996)
#endif


static idl_retcode_t
print_header(FILE *fh, const char *idl, const char *file)
{
  static const char fmt[] =
    "\"\"\"****************************************************************\n"
    "\n"
    "  Generated by Eclipse Cyclone DDS IDL to PY Translator\n"
    "  File name: %s\n"
    "  Source: %s\n"
    "  Cyclone DDS: v%s\n"
    "\n"
    "*****************************************************************\"\"\"\n";

  fprintf(fh, fmt, file, idl, IDL_VERSION);
  return IDL_RETCODE_OK;
}

static idl_retcode_t
generate_types(
  const idl_pstate_t *tree,
  const char *idl,
  const char *dir,
  const char *basename)
{
  char *dname = NULL;
  char *fname = NULL;
  const char *sep = strlen(dir) ? "/" : "";
  idl_backend_ctx ctx = NULL;
  idl_backend_py_ctx pctx = (idl_backend_py_ctx) malloc(sizeof(struct idl_backend_py_ctx_s));
  idl_retcode_t ret = IDL_RETCODE_OK;

  if (idl_asprintf(&dname, "%s%s%s", dir, sep, basename) == -1) {
    ret = IDL_RETCODE_NO_MEMORY;
    goto err;
  } else if (mkdir(dname, 0770) != 0) {
    goto err_mkdir;
  }
  if (idl_asprintf(&fname, "%s/__init__.py", dname) == -1)
    return IDL_RETCODE_NO_MEMORY;

  ctx = idl_backend_context_new(4, tree->files->name, NULL);
  idl_file_out_new(ctx, fname);
  pctx->basedir = dname;
  pctx->target_file = tree->files->name;
  idl_set_custom_context(ctx, pctx);

  print_py_imports(ctx);
  
  ret = idl_backendGenerateType(ctx, tree);


  idl_file_out_close(ctx);
  idl_reset_custom_context(ctx);
  idl_backend_context_free(ctx);
  free(pctx);
err_mkdir:
  free(fname);
  free(dname);
err:
  return ret;
}

#if _WIN32
__declspec(dllexport)
#endif
idl_retcode_t
generate(const idl_pstate_t *tree, const char *path)
{
  bool abs = false;
  const char *sep, *ext, *file;
  char *dir = NULL, *basename = NULL;

  if (!tree || !path)
    return IDL_RETCODE_SEMANTIC_ERROR; // not really, actually BAD_PARAMETER;

#if _WIN32
  if (((path[0] >= 'a' && path[0] <= 'z') || (path[0] >= 'A' && path[0] <= 'Z')) &&
       (path[1] == ':') &&
       (path[2] == '/' || path[2] == '\\'))
  {
    abs = true;
  }
#endif
  if (path[0] == '/') {
    abs = true;
  }

  /* use relative directory if user provided a relative path, use current
     work directory otherwise */
  sep = ext = NULL;
  for (const char *ptr = path; ptr[0]; ptr++) {
    if ((ptr[0] == '/' || ptr[0] == '\\') && ptr[1] != '\0')
      sep = ptr;
  }

  for (const char *ptr = (sep ? sep : path); ptr[0]; ptr++) {
    if (ptr[0] == '.')
      ext = ptr;
  }

  file = sep ? sep + 1 : path;
  dir = (!abs && sep) ? idl_strndup(path, (size_t)(sep-path)) : idl_strdup("");
  if (!dir) {
    return IDL_RETCODE_NO_MEMORY;
  } else if (!(basename = idl_strndup(file, ext ? (size_t)(ext-file) : strlen(file)))) {
    free(dir);
    return IDL_RETCODE_NO_MEMORY;
  }

  /* replace backslashes by forward slashes */
  for (char *ptr = dir; *ptr; ptr++) {
    if (*ptr == '\\')
      *ptr = '/';
  }

  generate_types(tree, path, dir, basename);

  free(dir);
  free(basename);
  return IDL_RETCODE_OK;
}
